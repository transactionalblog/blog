@inproceedings{CritiqueOfSnapshotIsolation,
    author = {Yabandeh, Maysam and Gomez Ferro, Daniel},
    title = {A critique of snapshot isolation},
    year = {2012},
    isbn = {9781450312233},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    _url = {https://doi.org/10.1145/2168836.2168853},
    _doi = {10.1145/2168836.2168853},
    abstract = {The support for transactions is an essential part of a database management system (DBMS). Without this support, the developers are burdened with ensuring atomic execution of a transaction despite failures as well as concurrent accesses to the database by other transactions. Ideally, a transactional system provides serializability, which means that the outcome of concurrent transactions is equivalent to a serial execution of them. Based on experiences on lock-based implementations, nevertheless, serializability is known as an expensive feature that comes with high overhead and low concurrency. Commercial systems, hence, compromise serializability by implementing weaker guarantees such as snapshot isolation. The developers, therefore, are still burdened with the anomalies that could arise due to the lack of serializability.There have been recent attempts to enrich large-scale data stores, such as HBase and BigTable, with transactional support. Not surprisingly, inspired by traditional database management systems, serializability is usually compromised for the benefit of efficiency. For example, Google Percolator, implements lock-based snapshot isolation on top of BigTable. We show in this paper that this compromise is not necessary in lock-free implementations of transactional support. We introduce write-snapshot isolation, a novel isolation level that has a performance comparable with that of snapshot isolation, and yet provides serializability. The main insight in write-snapshot isolation is to prevent read-write conflicts in contrast to write-write conflicts that are prevented by snapshot isolation.},
    booktitle = {Proceedings of the 7th ACM European Conference on Computer Systems},
    pages = {155-168},
    numpages = {14},
    keywords = {write-write conflict, transactions, snapshot isolation, serializability, read-write conflict, lock-free transactional support, key-value stores, distributed data stores, HBase},
    location = {Bern, Switzerland},
    series = {EuroSys '12},
    refname = {A Critique of Snapshot Isolation},
    scholarcluster = {11112563942774927788},
    arxiv = {2405.18393},
}
@article{EvaluationOfMVCC,
    author = {Wu, Yingjun and Arulraj, Joy and Lin, Jiexi and Xian, Ran and Pavlo, Andrew},
    title = {An empirical evaluation of in-memory multi-version concurrency control},
    year = {2017},
    issue_date = {March 2017},
    publisher = {VLDB Endowment},
    volume = {10},
    number = {7},
    issn = {2150-8097},
    _url = {https://doi.org/10.14778/3067421.3067427},
    _doi = {10.14778/3067421.3067427},
    abstract = {Multi-version concurrency control (MVCC) is currently the most popular transaction management scheme in modern database management systems (DBMSs). Although MVCC was discovered in the late 1970s, it is used in almost every major relational DBMS released in the last decade. Maintaining multiple versions of data potentially increases parallelism without sacrificing serializability when processing transactions. But scaling MVCC in a multi-core and in-memory setting is non-trivial: when there are a large number of threads running in parallel, the synchronization overhead can outweigh the benefits of multi-versioning.To understand how MVCC perform when processing transactions in modern hardware settings, we conduct an extensive study of the scheme's four key design decisions: concurrency control protocol, version storage, garbage collection, and index management. We implemented state-of-the-art variants of all of these in an in-memory DBMS and evaluated them using OLTP workloads. Our analysis identifies the fundamental bottlenecks of each design choice.},
    journal = {Proc. VLDB Endow.},
    month = {mar},
    pages = {781-792},
    numpages = {12},
    refname = {Evaluation of In-Memory MVCC},
    scholarcluster = {5271619414671440787},
}